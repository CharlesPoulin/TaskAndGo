// scheduler_server.go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    "sync"

    "google.golang.org/grpc"
    pb "your/repo/path/scheduler" // Import generated proto package
)

// In-memory store of tasks (for demonstration)
type TaskStore struct {
    mu   sync.Mutex
    data map[string]string // key: task_id, value: status
}

type SchedulerServer struct {
    pb.UnimplementedSchedulerServer
    store *TaskStore
}

func (s *SchedulerServer) SubmitTask(ctx context.Context, req *pb.SubmitTaskRequest) (*pb.SubmitTaskResponse, error) {
    // Lock store while adding new tasks
    s.store.mu.Lock()
    defer s.store.mu.Unlock()

    task := req.GetTask()
    if _, exists := s.store.data[task.TaskId]; exists {
        return &pb.SubmitTaskResponse{
            Success: false,
            Message: "Task with this ID already exists",
        }, nil
    }

    // Insert the task in a “QUEUED” state
    s.store.data[task.TaskId] = "QUEUED"
    log.Printf("Received task %s with priority %s", task.TaskId, task.Priority)

    // In a real scenario, you would push this task to a worker queue or a job orchestrator
    go s.executeTask(task.TaskId)

    return &pb.SubmitTaskResponse{
        Success: true,
        Message: "Task submitted successfully",
    }, nil
}

// Simulate execution of a task
func (s *SchedulerServer) executeTask(taskID string) {
    // Update status to RUNNING
    s.store.mu.Lock()
    s.store.data[taskID] = "RUNNING"
    s.store.mu.Unlock()

    // Simulate the “doing work” with a simple sleep
    // time.Sleep(10 * time.Second)

    // Once done, update to COMPLETED
    s.store.mu.Lock()
    s.store.data[taskID] = "COMPLETED"
    s.store.mu.Unlock()

    log.Printf("Task %s completed execution", taskID)
}

func (s *SchedulerServer) GetTaskStatus(ctx context.Context, req *pb.TaskStatusRequest) (*pb.TaskStatusResponse, error) {
    s.store.mu.Lock()
    defer s.store.mu.Unlock()

    status, found := s.store.data[req.GetTaskId()]
    if !found {
        return &pb.TaskStatusResponse{
            Found:   false,
            Message: "Task not found",
        }, nil
    }

    return &pb.TaskStatusResponse{
        Found:          true,
        CurrentStatus:  status,
        Message:        fmt.Sprintf("Task %s is in %s state", req.GetTaskId(), status),
    }, nil
}

func main() {
    // Create the in-memory store
    taskStore := &TaskStore{
        data: make(map[string]string),
    }

    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }

    grpcServer := grpc.NewServer()
    pb.RegisterSchedulerServer(grpcServer, &SchedulerServer{store: taskStore})

    log.Println("Scheduler Server listening on port :50051")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("Failed to serve: %v", err)
    }
}
